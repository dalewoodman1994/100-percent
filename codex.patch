 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/api/questionset.js b/api/questionset.js
index 36feb36909e59fe93f185d5df15414efc542429e..631defa67320acaefa58f6c0b0ee6c046f0b0d8e 100644
--- a/api/questionset.js
+++ b/api/questionset.js
@@ -1,28 +1,28 @@
 // Vercel Serverless Function: /api/questionset
 // Flags:
-// - Quickfire: 30 questions ramping difficulty: 10 Tier1 + 10 Tier2 + 10 Tier3
+// - Quickfire: 30 questions ramping difficulty: 12 Tier1 + 10 Tier2 + 8 Tier3
 // - Hardmode: all 195 shuffled
 // No caching so each run is unique.
 
 let flagsCache = {
   loaded: false,
   countries: [],
 };
 
 const RESTCOUNTRIES_ALL =
   "https://restcountries.com/v3.1/all?fields=name,cca2,unMember";
 
 const OBSERVER_STATES = new Set(["Vatican City", "Palestine"]);
 
 // ----------------------------
 // Difficulty tiers (by ISO A2 code)
 // Tiering is about recognisability, not population.
 // You can tweak these lists anytime based on player feedback.
 // ----------------------------
 const TIER_1 = [
   "US","GB","FR","DE","IT","ES","PT","NL","BE","CH","AT","IE",
   "CA","AU","NZ","JP","CN","IN","BR","AR","MX",
   "ZA","EG","TR","RU","KR","SE","NO","DK","FI","PL","GR"
 ];
 
 const TIER_2 = [
@@ -122,110 +122,110 @@ async function loadFlagsIntoCache() {
 
   flagsCache = {
     loaded: true,
     countries: deduped,
   };
 }
 
 // Build a quickfire run with tier ramping
 function buildTieredQuickfire(allCountries) {
   const byCode = new Map(allCountries.map((c) => [c.cca2, c]));
 
   // Filter tiers down to only codes that exist in our 195 list
   const tier1 = unique(TIER_1).filter((code) => byCode.has(code));
   const tier2 = unique(TIER_2).filter((code) => byCode.has(code));
   const tier3 = unique(TIER_3).filter((code) => byCode.has(code));
 
   // Safety: if tier lists are missing some codes, we top up from remaining pool
   const used = new Set();
 
   function takeFromTier(tierCodes, count) {
     const picks = pickRandomFrom(tierCodes, count);
     picks.forEach((c) => used.add(c));
     return picks;
   }
 
-  let q1 = takeFromTier(tier1, 10);
+  let q1 = takeFromTier(tier1, 12);
   let q2 = takeFromTier(tier2, 10);
-  let q3 = takeFromTier(tier3, 10);
+  let q3 = takeFromTier(tier3, 8);
 
-  // Top-up logic (if any tier had <10 available due to list mismatch)
+  // Top-up logic (if any tier had fewer available due to list mismatch)
   const need = 30 - (q1.length + q2.length + q3.length);
   if (need > 0) {
     const remaining = allCountries
       .map((c) => c.cca2)
       .filter((code) => !used.has(code));
     const extra = pickRandomFrom(remaining, need);
     // Put extras into the hardest section so early game stays easy
     q3 = q3.concat(extra);
   }
 
   // Keep ramp: shuffle within each tier only (so order still feels fresh)
   shuffleInPlace(q1);
   shuffleInPlace(q2);
   shuffleInPlace(q3);
 
   const runCodes = [...q1, ...q2, ...q3];
   const runCountries = runCodes.map((code) => byCode.get(code)).filter(Boolean);
 
   return runCountries;
 }
 
 // ----------------------------
 // Handler
 // ----------------------------
 module.exports = async (req, res) => {
   try {
     const mode = String(req.query.mode || "quickfire").toLowerCase();
     const category = String(req.query.category || "flags").toLowerCase();
 
     if (category !== "flags") {
       return res.status(400).json({
         error: "Unknown category. Only 'flags' supported right now.",
       });
     }
 
     if (!flagsCache.loaded) {
       await loadFlagsIntoCache();
     }
 
     const totalPlanned = mode === "hardmode" ? 195 : 30;
 
     let runCountries;
 
     if (mode === "hardmode") {
       // Hardmode: full 195, shuffled
       runCountries = [...flagsCache.countries];
       shuffleInPlace(runCountries);
       runCountries = runCountries.slice(0, 195);
     } else {
-      // Quickfire: tier ramp 10/10/10
+      // Quickfire: tier ramp 12/10/8
       runCountries = buildTieredQuickfire(flagsCache.countries);
       runCountries = runCountries.slice(0, 30);
     }
 
     const questions = runCountries.map((c) =>
       buildMultipleChoiceQuestion(c, flagsCache.countries)
     );
 
     // No caching: each request should be unique
     res.setHeader(
       "Cache-Control",
       "no-store, no-cache, must-revalidate, proxy-revalidate"
     );
     res.setHeader("Pragma", "no-cache");
     res.setHeader("Expires", "0");
 
     return res.json({
       mode,
       category,
       totalPlanned,
       totalAvailable: flagsCache.countries.length,
       totalUsed: questions.length,
       questions,
       generatedAt: Date.now(),
-      quickfireRamp: mode !== "hardmode" ? { tier1: 10, tier2: 10, tier3: 10 } : null,
+      quickfireRamp: mode !== "hardmode" ? { tier1: 12, tier2: 10, tier3: 8 } : null,
     });
   } catch (e) {
     return res.status(500).json({ error: e.message });
   }
 };
 
EOF
)